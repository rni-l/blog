---
title: 设计模式 - 阅读
date: 2023-06-23 09:22:00
tags: ["reading", "head-first-design-patterns"]
categories: ["记录"]
---

## 其他概念

### 什么是模式？
> 在某个上下文中针对某个问题的解决方案

## 设计原则

1. 封装变化
2. 组合优于继承
3. 针对接口编程，而不是针对实现
4. 尽力达到交互对象之间的松耦合设计
5. 类应该对扩展开放，对修改关闭
6. 依赖抽象，不依赖具体类
7. 最少知识原则，减少对象之间的交互
8. 单一责任原则
9. 保持简单（keep it simple & stupid, KISS）




### 松耦合

> 松耦合设计允许我们建造能够应对变化的、有弹性的 OO 系统，因为对象之间的互相依赖降到最低。
> -- head first design patterns


### 开放关闭原则

^e443d4

开放关闭原则强调的是在软件设计中应该通过扩展现有代码的方式来实现新功能，而不是通过修改已有的代码。这样做的好处是能够减少对现有代码的影响，降低引入新问题的风险，同时提高代码的可维护性和可扩展性。

实现开放关闭原则的关键在于将变化的部分和稳定的部分分离开来。通常通过定义抽象的接口或基类来表示稳定的部分，然后通过实现这些接口或继承这些基类来扩展功能。这样，当需要添加新的功能时，只需要编写新的实现类或子类，而不需要修改现有的代码。

开放关闭原则也与设计模式中的一些模式密切相关，如策略模式（Strategy Pattern）和装饰器模式（Decorator Pattern），它们都是通过遵循开放关闭原则来实现灵活的功能扩展。

总结起来，开放关闭原则是一种指导软件设计的原则，它鼓励通过扩展而不是修改来实现新功能，从而提高代码的可维护性、可扩展性和稳定性。

### 依赖倒置原则（Dependency Inversion Principle）

强调对抽象的封装而不是具体的类

![[what-is-dependency-inversion.excalidraw]]

由“顶层依赖底层”变成“顶层依赖抽象层，底层依赖于抽象层”。
遵循该原则的指南：
1. 变量不应该持有到具体类的引用
2. 类不应该派生自具体类
3. 方法不应该覆盖其任何基类的已实现方法

### 最少知识原则

任何对象，该对象的任何方法中，只调用属于以下范围的方法：
1. 对象自身
2. 作为参数传给方法的对象
3. 该方法创建或实例化的任何对象
4. 对象的任何组件

demo:
```javascript
// bad
getTemp() {
  const a = s.getA()
  return a.getB() // 该方法目标只是获取 a 对象，获取 b 对象是调用 getTemp 方法后做的事情
}

// good
getTemp() {
  return s.getA()
}

```

### 单一责任原则
一个类应该只有一个变化的原因

